package timeutil

import (
	"testing"
	"time"
)

func TestNextMonth(t *testing.T) {
	layout := time.RFC3339Nano

	cases := []struct {
		at       string
		expected string
	}{
		{
			"2020-01-01T00:00:00.000000000+09:00", // 年始
			"2020-02-01T00:00:00.000000000+09:00", // 31日またぎ
		},
		{
			"2020-02-01T00:00:00.000000000+09:00",
			"2020-03-01T00:00:00.000000000+09:00", // 閏日またぎ
		},
		{
			"2020-12-01T00:00:00.000000000+09:00",
			"2021-01-01T00:00:00.000000000+09:00", // 年末またぎ
		},
		{
			"2021-02-01T00:00:00.000000000+09:00",
			"2021-03-01T00:00:00.000000000+09:00", // 閏日がない場合の2月またぎ
		},
		{
			"2021-12-01T12:34:56.789012345-02:00", // 適当な時刻
			"2022-01-01T00:00:00.000000000-02:00",
		},
		{
			"2100-02-01T00:00:00.000000000+09:00",
			"2100-03-01T00:00:00.000000000+09:00", // うるう年の例外(閏日なし.100で割れる年)
		},
		{
			"2000-02-01T00:00:00.000000000+09:00",
			"2000-03-01T00:00:00.000000000+09:00", // うるう年の例外の例外(閏日あり.400で割れる年)
		},
	}

	for _, c := range cases {
		target, _ := time.Parse(layout, c.at)
		expected, _ := time.Parse(layout, c.expected)

		result := NextMonth(target)
		if !result.Equal(expected) {
			t.Errorf("NextMonth(%s) should be %s, but got %s", target, expected, result.Format(layout))
		}
	}
}

func TestEndOfMonth(t *testing.T) {
	layout := time.RFC3339Nano

	cases := []struct {
		at       string
		expected string
	}{
		{
			"2020-01-01T00:00:00.000000000+09:00", // 年始
			"2020-01-31T23:59:59.999999999+09:00", // 31日末日の月
		},
		{
			"2020-02-01T00:00:00.000000000+09:00",
			"2020-02-29T23:59:59.999999999+09:00", // うるう年
		},
		{
			"2020-11-01T00:00:00.000000000+09:00",
			"2020-11-30T23:59:59.999999999+09:00", // 30日末日の月
		},
		{
			"2020-12-01T00:00:00.000000000+09:00",
			"2020-12-31T23:59:59.999999999+09:00", // 年末
		},
		{
			"2021-02-01T00:00:00.000000000+09:00",
			"2021-02-28T23:59:59.999999999+09:00", // うるう年ではない2月
		},
		{
			"2021-12-12T12:34:56.789012345-02:00", // 適当な時刻
			"2021-12-31T23:59:59.999999999-02:00",
		},
		{
			"2100-02-01T00:00:00.000000000+09:00",
			"2100-02-28T23:59:59.999999999+09:00", // うるう年の例外(閏日なし.100で割れる年)
		},
		{
			"2000-02-01T00:00:00.000000000+09:00",
			"2000-02-29T23:59:59.999999999+09:00", // うるう年の例外の例外(閏日あり.400で割れる年)
		},
	}

	for _, c := range cases {
		target, _ := time.Parse(layout, c.at)
		expected, _ := time.Parse(layout, c.expected)

		result := EndOfMonth(target)
		if !result.Equal(expected) {
			t.Errorf("EndOfMonth(%s) should be %s, but got %s", target, expected, result.Format(layout))
		}
	}
}

func TestLastDayOfMonth(t *testing.T) {
	layout := time.RFC3339Nano

	cases := []struct {
		at       string
		expected string
	}{
		{
			"2020-01-01T00:00:00.000000000+09:00", // 年始
			"2020-01-31T00:00:00.000000000+09:00", // 31日末日の月
		},
		{
			"2020-02-01T00:00:00.000000000+09:00",
			"2020-02-29T00:00:00.000000000+09:00", // うるう年
		},
		{
			"2020-11-01T00:00:00.000000000+09:00",
			"2020-11-30T00:00:00.000000000+09:00", // 30日末日の月
		},
		{
			"2020-12-01T00:00:00.000000000+09:00",
			"2020-12-31T00:00:00.000000000+09:00", // 年末
		},
		{
			"2021-02-01T00:00:00.000000000+09:00",
			"2021-02-28T00:00:00.000000000+09:00", // うるう年ではない2月
		},
		{
			"2021-12-12T12:34:56.789012345-02:00", // 適当な時刻
			"2021-12-31T00:00:00.000000000-02:00",
		},
		{
			"2100-02-01T00:00:00.000000000+09:00",
			"2100-02-28T00:00:00.000000000+09:00", // うるう年の例外(閏日なし.100で割れる年)
		},
		{
			"2000-02-01T00:00:00.000000000+09:00",
			"2000-02-29T00:00:00.000000000+09:00", // うるう年の例外の例外(閏日あり.400で割れる年)
		},
	}

	for _, c := range cases {
		target, _ := time.Parse(layout, c.at)
		expected, _ := time.Parse(layout, c.expected)

		result := LastDayOfMonth(target)
		if !result.Equal(expected) {
			t.Errorf("LastDayOfMonth(%s) should be %s, but got %s", target, expected, result.Format(layout))
		}
	}

}

func TestCorrespondingDate(t *testing.T) {
	layout := time.RFC3339Nano

	args := []struct {
		y int
		m int
	}{
		{0, 1},   // 翌月
		{0, 2},   // 翌々月
		{0, 12},  // 翌年
		{1, 0},   // 翌年
		{1, 1},   // 1年1ヶ月後
		{0, 120}, // 10年後
		{10, 11}, // 10年11ヶ月後
	}

	cases := []struct {
		at       string
		expected []string
	}{
		{
			"2020-01-01T00:00:00.000000000+09:00", // 年始
			[]string{
				"2020-02-01T00:00:00.000000000+09:00", // 翌月
				"2020-03-01T00:00:00.000000000+09:00", // 翌々月
				"2021-01-01T00:00:00.000000000+09:00", // 翌年
				"2021-01-01T00:00:00.000000000+09:00", // 翌年
				"2021-02-01T00:00:00.000000000+09:00", // 1年1ヶ月後
				"2030-01-01T00:00:00.000000000+09:00", // 10年後
				"2030-12-01T00:00:00.000000000+09:00", // 10年11ヶ月後
			},
		},
		{
			"2020-01-31T00:00:00.000000000+09:00", // 31日の処理
			[]string{
				"2020-02-29T00:00:00.000000000+09:00", // 翌月 うるう年の場合は29日
				"2020-03-31T00:00:00.000000000+09:00", // 翌々月 31日がある月
				"2021-01-31T00:00:00.000000000+09:00", // 翌年
				"2021-01-31T00:00:00.000000000+09:00", // 翌年
				"2021-02-28T00:00:00.000000000+09:00", // 1年1ヶ月後 うるう年でないので28日
				"2030-01-31T00:00:00.000000000+09:00", // 10年後
				"2030-12-31T00:00:00.000000000+09:00", // 10年11ヶ月後
			},
		},
		{
			"2020-11-30T00:00:00.000000000+09:00", // 30日の処理
			[]string{
				"2020-12-30T00:00:00.000000000+09:00", // 翌月
				"2021-01-30T00:00:00.000000000+09:00", // 翌々月
				"2021-11-30T00:00:00.000000000+09:00", // 翌年
				"2021-11-30T00:00:00.000000000+09:00", // 翌年
				"2021-12-30T00:00:00.000000000+09:00", // 1年1ヶ月後
				"2030-11-30T00:00:00.000000000+09:00", // 10年後
				"2031-10-30T00:00:00.000000000+09:00", // 10年11ヶ月後
			},
		},
		{
			"2100-01-31T00:00:00.000000000+09:00", // 31日の処理
			[]string{
				"2100-02-28T00:00:00.000000000+09:00", // 翌月 うるう年の例外年なので28日
				"2100-03-31T00:00:00.000000000+09:00", // 翌々月 31日がある月
				"2101-01-31T00:00:00.000000000+09:00", // 翌年
				"2101-01-31T00:00:00.000000000+09:00", // 翌年
				"2101-02-28T00:00:00.000000000+09:00", // 1年1ヶ月後 うるう年でないので28日
				"2110-01-31T00:00:00.000000000+09:00", // 10年後
				"2110-12-31T00:00:00.000000000+09:00", // 10年11ヶ月後
			},
		},
	}

	for _, c := range cases {
		target, _ := time.Parse(layout, c.at)
		for k, arg := range args {
			expected, _ := time.Parse(layout, c.expected[k])

			result := CorrespondingDate(target, arg.y, arg.m)
			if !result.Equal(expected) {
				t.Errorf("CorrespondingDate(%s,%d,%d) should be %s, but got %s", target, arg.y, arg.m, expected, result.Format(layout))
			}
		}
	}
}
